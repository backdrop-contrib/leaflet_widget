<?php
/**
 * @file
 * Leaflet widget module for Geofield.
 */

/**
 * Implements hook_field_widget_info().
 */
function leaflet_widget_field_widget_info() {
  $widgets = array();

  $widgets['leaflet_widget_widget'] = array(
    'label' => 'Leaflet.widget',
    'description' => t('Provides a map powered by Leaflet and Leaflet.draw.'),
    'field types' => array('geofield'),
    'settings' => array(
      'map' => array(
        'base_layer' => 'osm_mapnik_base',
        'center' => array(
          'lat' => 0.0,
          'lng' => 0.0,
        ),
        'auto_center' => TRUE,
        'zoom' => 10,
        'height' => 400,
      ),
    ),
    'behaviors' => array(
      'multiple values' => FIELD_BEHAVIOR_CUSTOM,
      'default value' => FIELD_BEHAVIOR_NONE,
    ),
  );

  return $widgets;
}

/**
 * Implements hook_field_widget_settings_form().
 */
function leaflet_widget_field_widget_settings_form($field, $instance) {
  $form = array();
  $settings = $instance['widget']['settings'];

  switch ($instance['widget']['type']) {
    case 'leaflet_widget_widget':
      $form['map'] = array(
        '#type' => 'fieldset',
        '#title' => t('Default map settings'),
      );
      $form['map']['base_layer'] = array(
        '#type' => 'select',
        '#title' => t('Leaflet.draw widget settings'),
        '#default_value' => !empty($settings['map']['base_layer']) ? $settings['map']['base_layer'] : 'osm_mapnik_base',
        '#options' => leaflet_widget_base_layers_form_options(),
      );
      $form['map']['center'] = array(
        '#type' => 'fieldset',
        '#collapsed' => TRUE,
        '#collapsible' => TRUE,
        '#title' => 'Default map center',
      );
      $form['map']['center']['lat'] = array(
        '#type' => 'textfield',
        '#title' => t('Latitude'),
        '#default_value' => $settings['map']['center']['lat'],
        '#required' => TRUE,
      );
      $form['map']['center']['lng'] = array(
        '#type' => 'textfield',
        '#title' => t('Longtitude'),
        '#default_value' => $settings['map']['center']['lng'],
        '#required' => TRUE,
      );
      $form['map']['auto_center'] = array(
        '#type' => 'checkbox',
        '#title' => t('Automatically center map on existing features'),
        '#description' => t("This option overrides the widget's default center."),
        '#default_value' => $settings['map']['auto_center'],
      );
      $form['map']['zoom'] = array(
        '#type' => 'textfield',
        '#title' => t('Default zoom level'),
        '#default_value' => $settings['map']['zoom'],
        '#required' => TRUE,
      );
      $form['map']['height'] = array(
        '#type' => 'number',
        '#title' => t('Height (px)'),
        '#min' => '100',
        '#max' => '800',
        '#step' => '10',
        '#default_value' => $settings['map']['height'],
        '#required' => TRUE,
      );

      break;
  }

  return $form;
}

/**
 * Implements hook_field_widget_form().
 */
function leaflet_widget_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  $settings = $instance['widget']['settings'];

  $element['#type'] = 'fieldset';

  // $element['input_format'] is not a db field, but we use it determine how to
  // parse/calculate values in our widget.
  $element['input_format'] = array(
    '#type' => 'value',
    '#attributes' => array('class' => array('geofield_input_format')),
    '#value' => GEOFIELD_INPUT_AUTO_DISCOVER,
  );

  switch ($instance['widget']['type']) {
    case 'leaflet_widget_widget':
      $id = 'leaflet-widget_' . backdrop_html_id(str_replace('_', '-', $instance['field_name']));
      $class = 'leaflet-widget';
      $style = 'height: ' . $settings['map']['height'] . 'px;';
      $input_id = $id . '-input';

      // Provide container markup for map form element.
      $container = "<div id=\"$id\" class=\"$class\" style=\"$style\"></div>";
      $element['leaflet_widget'] = array('#markup' => $container);
      $element['input_format']['#value'] = GEOFIELD_INPUT_GEOJSON;

      // Overriding Geofield's validation handler.
      $element['#element_validate'] = array('leaflet_widget_widget_validate');

      // Prepare existing field values to be rendered in widget.
      $geom_type = 'wkt';
      if (!empty($form_state['process_input'])) {
        // If the input was processed it ran through
        // leaflet_widget_process_geojson() which uses geofield_compute_values()
        // and this function returns wkb format. So adjust our parsing to avoid
        // nasty sideeffects.
        $geom_type = 'wkb';
      }
      $collection = leaflet_widget_widget_prepare_items($items, $geom_type);

      $element['geom'] = array(
        '#type' => 'hidden',
        '#title' => check_plain($instance['label']),
        '#description' => check_plain($instance['description']),
        '#default_value' => backdrop_json_encode($collection),
        '#required' => $instance['required'],
        '#attributes' => array('id' => $input_id),
      );

      // Convert field settings to Javascript settings.
      $widget_settings = array();
      $widget_settings['widget'] = array(
        'cardinality' => $field['cardinality'],
        'autoCenter' => $settings['map']['auto_center'],
      );
      $widget_settings['map_options'] = array(
        'center' => array(
          0 => $settings['map']['center']['lat'],
          1 => $settings['map']['center']['lng'],
        ),
        'zoom' => $settings['map']['zoom'],
      );

      $layer_settings = leaflet_widget_get_layer_setting($settings['map']['base_layer']);
      $widget_settings['layer'] = array(
        0 => $layer_settings['url_template'],
        1 => $layer_settings['layer_options'],
      );

      $element['#attached']['library'][] = array('leaflet_widget', 'Leaflet.draw');
      $element['#attached']['js'][] = backdrop_get_path('module', 'leaflet_widget') . '/js/leaflet-widget.js';
      $element['#attached']['js'][] = array(
        'type' => 'setting',
        'data' => array('leaflet_geofield_widget' => array($id => $widget_settings)),
      );
      $element['#attached']['css'][] = backdrop_get_path('module', 'leaflet_widget') . '/css/leaflet-widget.css';

      break;
  }

  return $element;
}

/**
 * Prepares the field items - return a geoJSON FeatureCollection.
 *
 * @param array $items
 *   The items to prepare as provided by hook_field_widget_form().
 * @param string|NULL $geom_type
 *   The geometry type the geometry data are given. Set to NULL to use
 *   autodetect. It's recommended to define the type to speed up processing.
 *
 * @return array
 *   A geoJSON FeatureCollection.
 */
function leaflet_widget_widget_prepare_items($items, $geom_type = 'wkt') {
  $features = array();
  foreach ($items as $item) {
    if (isset($item['geom'])) {
      // Set geom type to NULL - it can be wkt or wkb depending on the form
      // state.
      $features[] = leaflet_widget_geojson_feature($item['geom'], array(), $geom_type);
    }
  }
  return leaflet_widget_geojson_feature_collection($features);
}

/**
 * Widget validation callback.
 *
 * This is used to process the posted values to proper geofield values.
 */
function leaflet_widget_widget_validate($element, &$form_state) {
  module_load_include('inc', 'geofield', 'libraries/geophp/geoPHP');

  $geojson = $element['geom']['#value'];
  $results = array(leaflet_widget_process_geojson($geojson));

  form_set_value($element, $results, $form_state);
}

/**
 * Ensures the posted values match the geofield values.
 *
 * @param string $geojson
 *   The geoJSON values.
 *
 * @return array
 *   List of geofield compatible values.
 */
function leaflet_widget_process_geojson($geojson) {
  $geom = geoPHP::load($geojson, 'json');
  // Avoid throwing a notice if there was a failure.
  if (!$geom) {
    return array();
  }
  $type = $geom->geometryType();
  $result = array(
    'geom' => $geom->out('wkt'),
    'input_format' => 'wkt',
  );
  return geofield_compute_values($result);
}

/**
 * Implements hook_library_info().
 */
function leaflet_widget_library_info() {
  $libraries_path = backdrop_get_path('module', 'leaflet_widget') . '/libraries';

  $libraries['Leaflet.draw'] = array(
    'title' => t('Leaflet Draw Library'),
    'version' => '0.4.14',
    'website' => 'https://github.com/Leaflet/Leaflet.draw',
    'js' => array(
      $libraries_path . '/Leaflet.draw/dist/leaflet.draw-src.js' => array(
        'type' => 'file',
        'group' => JS_LIBRARY,
      ),
    ),
    'css' => array(
      $libraries_path . '/Leaflet.draw/dist/leaflet.draw.css' => array(
        'type' => 'file',
        'media' => 'all',
      ),
    ),
    'dependencies' => array(
      array('leaflet', 'leaflet'),
    ),
  );

  return $libraries;
}

/**
 * Creates a geoJSON FeatureCollection out of an array of features.
 *
 * @param array $features
 *   The features to pack into the FeatureCollection.
 *
 * @return array
 *   A geoJSON FeatureCollection.
 */
function leaflet_widget_geojson_feature_collection($features) {
  if (!is_array($features)) {
    $features = array($features);
  }

  return array(
    'type' => 'FeatureCollection',
    'features' => $features,
  );
}

/**
 * Creates a geoJSON feature from a geofield geom value.
 *
 * @param string $geom
 *   Well known text value.
 * @param array $properties
 *   Properties for the geoJSON feature.
 * @param string|NULL $geom_type
 *   The geometry type the geometry data are given. Set to NULL to use
 *   autodetect. It's recommended to define the type to speed up processing.
 *
 * @return array|bool
 *   Returns a geoJSON feature or FALSE on failure.
 */
function leaflet_widget_geojson_feature($geom, $properties = array(), $geom_type = 'wkt') {
  module_load_include('inc', 'geofield', 'libraries/geophp/geoPHP');
  $geometry = geoPHP::load($geom, $geom_type);
  // Avoid notice on error.
  if (!$geometry) {
    return FALSE;
  }

  return array(
    'type' => 'Feature',
    'geometry' => json_decode($geometry->out('json')),
    'properties' => $properties,
  );
}

/**
 * Implements hook_leaflet_widget_base_layers().
 */
function leaflet_widget_leaflet_widget_base_layers() {
  $layertypes = array(
    'osm_mapnik_base' => array(
      'label' => t('OSM Mapnik'),
      'url_template' => 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
      'layer_options' => array(
        'attribution' => '<a href="https://www.openstreetmap.org/copyright" target="_blank">© OpenStreetMap </a> contributors',
      ),
    ),
  );

  return $layertypes;
}

/**
 * Helper function that returns available base layers usable as option list.
 */
function leaflet_widget_base_layers_form_options() {
  $form_options = array();
  $available = leaflet_widget_base_layers();
  foreach ($available as $machine_name => $options) {
    $form_options[$machine_name] = $options['label'];
  }
  return $form_options;
}

/**
 * Helper function to retrieve layer settings by name.
 *
 * @param string $layer_name
 *   The name of the layer as defined in leaflet_widget_base_layers().
 *
 * @return array
 *   Array of layer settings.
 */
function leaflet_widget_get_layer_setting($layer_name) {
  $available = leaflet_widget_base_layers();
  if (isset($available[$layer_name])) {
    return $available[$layer_name];
  }
  // Fallback if layer definition is missing.
  return $available['osm_mapnik_base'];
}

/**
 * Returns the available leaflet base layers.
 *
 * Invokes hook_leaflet_widget_base_layers() to allow modules adding additional
 * layers just for the widget.
 *
 * @return array
 *   A list of leaflet layers to use.
 */
function leaflet_widget_base_layers() {
  $options = array();

  return array_merge($options, module_invoke_all('leaflet_widget_base_layers'));
}
